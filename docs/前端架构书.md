# 前端架构设计书与 API 协议

## 1. 概述 (Overview)

本项目是一个基于 Vue 3、Pinia 和 Element Plus 的高级单页应用 (SPA)。其核心功能是围绕“知识库 (Knowledge Base)”和“模型 (Model)”的管理、处理和应用。

### 1.1. 技术栈

* **核心框架:** Vue 3 (Composition API)
* **状态管理:** Pinia
* **UI 库:** Element Plus
* **图标:** `@element-plus/icons-vue`

### 1.2. 核心设计理念

* **状态驱动视图:** 整个应用的布局和组件显隐，完全由 Pinia store 中的状态驱动。`App.vue` 作为布局控制器，通过计算属性 (computed properties) 动态调整各面板（Panel）的 `flex-basis` 和 `opacity`，实现复杂的、带动画的布局切换。
* **集中式状态管理:** 业务逻辑和 API 调用被封装在 Pinia Stores (`knowledgeBaseStore`, `modelStore`) 中。Vue 组件负责触发 (dispatch) actions 和展示 (display) state，但不直接处理业务逻辑，实现了视图和逻辑的解耦。
* **组件化:** 功能被拆分为高度内聚的组件（如 `RightPanel.vue`, `ModelTablePanel.vue`, `CreateKnowledgeBasePanel.vue` 等），每个组件负责一块独立的 UI 和交互。

## 2. 高层架构 (High-Level Architecture)

应用架构可分为以下几个层次：

1.  **布局层 (Layout):**
    * `App.vue`: 唯一的应用根组件。它管理着三个主菜单 (`database`, `prompt`, `model`) 的切换，并作为所有“面板”的容器。它通过 CSS class (如 `.detail-is-open`, `.is-picking-mode`) 动态控制整体布局。

2.  **视图面板层 (View Panels):**
    * **主面板 (Main Panel):**
        * `TablePanel.vue`: 用于显示“知识库”表格。
        * `ModelTablePanel.vue`: 用于显示“模型”表格。
        * `App.vue` 控制在“主面板”中具体显示哪一个表格。
    * **详情面板 (Detail Panel):**
        * `RightPanel.vue`: 显示和操作“知识库”详情。
        * `ModelDetailPanel.vue`: 显示和操作“模型”详情。
    * **操作面板 (Action Panels):**
        * `CreateKnowledgeBasePanel.vue`: 创建知识库的表单。
        * `CreateModelPanel.vue`: 创建模型的表单。
        * `RegenerateKnowledgeBasePanel.vue`: 再生成子知识库的表单。
    * **组合面板 (Composition Panel):**
        * `PromptEditor.vue`: 在 "Prompt" 模式下显示，用于提示词工程。

3.  **状态与逻辑层 (State & Logic):**
    * `knowledgeBase.js` (`knowledgeBaseStore`): 负责所有知识库数据的增删改查、状态管理（包括复杂的“解析状态” `parsingState`）以及与后端的
        API 交互。
    * `modelStore.js` (从代码中推断): 负责所有模型数据的增删改查和状态管理。

4.  **API 服务层 (Service Layer - Implied):**
    * Pinia stores 内部（当前为模拟数据 `hardcodedData` 和 `setInterval`）是后端 API 调用的封装点。所有对后端的数据请求都应在此发起。

## 3. 核心业务流程分析

### 3.1. 知识库解析 (Knowledge Base Parsing)

这是系统中最复杂的多状态、跨组件流程：

1.  **触发 (RightPanel):** 用户在 `RightPanel.vue` (详情页) 点击“解析知识库”。
2.  **进入选择模式 (Store):** `handleParseClick` 调用 `knowledgeBaseStore.enterParsingMode(id)`，将该知识库的 `parsingState.stage` 更新为 `picking_model`。
3.  **布局切换 (App.vue):**
    * `App.vue` 中的 `isPickingForParsing` 计算属性变为 `true`。
    * `isModelTableVisible` 随之变为 `true`。
    * `main-panel-wrapper` 的 class 切换为 `show-model-table`，主面板从知识库表格切换为模型表格。
4.  **表格过滤 (ModelTablePanel):**
    * `ModelTablePanel.vue` 接收到 `isPickingEmbeddingModel` (即 `isPickingForParsing`) 为 `true`。
    * 其 `tableData` 计算属性自动过滤列表，只显示 `type === 'Embedding'` 的模型。
5.  **选择模型 (ModelTablePanel):** 用户点击一个 Embedding 模型，`handleRowClick` 调用 `modelStore.setSelectedModel(model)`。
6.  **UI 响应 (RightPanel):**
    * `RightPanel.vue` 监听到 `modelStore.selectedModel` 发生变化。
    * "确定" 按钮变为可点击状态。
7.  **确认解析 (RightPanel):** 用户点击“确定”，`handleConfirmParsing` 调用 `knowledgeBaseStore.startParsing(id)`。
8.  **开始解析 (Store):**
    * `startParsing` 更新知识库状态为 `processing`，`parsingState.stage` 变为 `parsing`。
    * (当前) store 使用 `setInterval` 模拟进度。 (未来) **此处应调用后端 API**。
9.  **显示进度 (RightPanel):** `RightPanel.vue` 实时显示 `parsingState.progress` 的进度条。
10. **完成/取消 (Store & RightPanel):**
    * `cancelParsing` 或 `finishParsing` (在 `startParsing` 的 `setInterval` 中) 会将 `parsingState.stage` 调回 `idle`。
    * `RightPanel.vue` 中的 `watch` 侦测到 `parsingState.stage` 从 `parsing` 变回 `idle`，并根据最终的 `status` ('ready' 或 'error') 弹出全局通知 (`ElNotification`)。

### 3.2. 子知识库再生成 (Sub-KB Regeneration)

1.  **触发 (RightPanel):** 用户点击“再生成子知识库”，触发 `App.vue` 显示 `RegenerateKnowledgeBasePanel.vue`。
2.  **状态切换 (RegenerateKnowledgeBasePanel):**
    * 面板默认为 `config` 模式。
    * 点击“选择父知识库”，`panelMode` 变为 `kb-picking`。`App.vue` 布局随之变化，显示主表格。
    * 点击“选择生成模型”，`panelMode` 变为 `model-picking`。`App.vue` 布局变化，显示模型表格。
3.  **选择数据 (TablePanel / ModelTablePanel):**
    * 用户在表格中选择数据，`selectedKnowledgeBase` 或 `selectedModel` 发生变化。
4.  **自动返回 (RegenerateKnowledgeBasePanel):**
    * `watch` 监听到 `kbStore.selectedKnowledgeBase` 或 `modelStore.selectedModel` 变化，自动将 `panelMode` 切回 `config`，并保存所选项。
5.  **提交 (RegenerateKnowledgeBasePanel):** 用户填写完表单，点击“确认生成”，调用 `kbStore.regenerateKnowledgeBase(...)`，**此处应调用后端 API**。

## 4. 后端 API 接口定义 (Expected Backend API)

以下是前端代码所期望的后端 API 接口。

### 4.1. 知识库 (Knowledge Base)

**Endpoint:** `/api/knowledge-bases`

| Method | Path | 描述 | 对应前端 |
| :--- | :--- | :--- | :--- |
| `GET` | `/` | 获取所有知识库列表 | `knowledgeBaseStore` 初始化 |
| `POST`| `/` | 创建一个新的知识库（**必须**使用 `multipart/form-data`） | `CreateKnowledgeBasePanel.vue` `handleSubmit` -> `store.createKnowledgeBase` |
| | | **Request Body (form-data):** `name` (string), `description` (string, optional), `parentId` (string, optional), `file` (File, **required**) | |
| `PATCH` | `/{id}` | 更新知识库的元数据（如名称） | `RightPanel.vue` `handleNameSave` -> `store.updateKnowledgeBase` |
| | | **Request Body (json):** `{ "name": "new name" }` | |
| `DELETE`| `/{id}` | 删除一个知识库 | `RightPanel.vue` `handleDelete` -> `store.deleteKnowledgeBase` |
| `POST` | `/{id}/re-upload` | 重新上传知识库的源文件（使用 `multipart/form-data`） | `RightPanel.vue` `handleFileChange` -> `store.reuploadFile` |
| | | **Request Body (form-data):** `file` (File, **required**) | |
| `POST` | `/{id}/regenerate` | 基于父知识库再生成一个子知识库 | `RegenerateKnowledgeBasePanel.vue` `handleSubmit` -> `store.regenerateKnowledgeBase` |
| | | **Request Body (json):** `{ "newName": "...", "modelId": "...", "options": { ... } }` | |

---

### 4.2. 知识库解析 (KB Parsing)

**Endpoint:** `/api/knowledge-bases/{id}/parse`

| Method | Path | 描述 | 对应前端 |
| :--- | :--- | :--- | :--- |
| `POST` | `/{id}/parse` | 启动一个异步解析任务 | `RightPanel.vue` `handleConfirmParsing` -> `store.startParsing` |
| | | **Request Body (json):** `{ "modelId": "..." }` | |
| | | **Response (json):** `{ "jobId": "...", "status": "parsing", "progress": 0 }` (返回任务 ID 和初始状态) | |
| `GET` | `/{id}/parse` | (推荐) 获取解析任务的当前状态 (前端应轮询此接口) | `store.startParsing` (代替 `setInterval`) |
| | | **Response (json):** `{ "jobId": "...", "status": "parsing" \| "ready" \| "error", "progress": 80 }` | |
| `DELETE`| `/{id}/parse` | (推荐) 取消一个正在进行的解析任务 | `RightPanel.vue` `handleCancelParsing` -> `store.cancelParsing` |

*注：* 当前前端使用 `setInterval` 模拟异步。后端应提供一个启动接口 (POST) 和一个状态查询接口 (GET)，前端通过轮询 (Polling) 或 WebSocket 替代 `setInterval` 来获取 `progress`。

---

### 4.3. 模型 (Model)

**Endpoint:** `/api/models`

| Method | Path | 描述 | 对应前端 |
| :--- | :--- | :--- | :--- |
| `GET` | `/` | 获取所有模型列表 | `modelStore` 初始化 |
| `POST`| `/` | 配置一个新模型 | `CreateModelPanel.vue` `handleSubmit` -> `store.addModel` |
| | | **Request Body (json):** `{ "name": "...", "type": "Embedding" \| "Normal", "apiKey": "...", "endpoint": "..." }` | |
| `PATCH` | `/{id}` | 更新一个模型的信息 | `ModelDetailPanel.vue` `handleSave` -> `store.updateModel` |
| | | **Request Body (json):** (同上) | |
| `DELETE`| `/{id}` | 删除一个模型 | `ModelDetailPanel.vue` `handleDelete` -> `store.deleteModel` |

---

### 4.4. 提示词 (Prompt)

**Endpoint:** `/api/prompts` (根据 `PromptEditor.vue` 推断)

| Method | Path | 描述 | 对应前端 |
| :--- | :--- | :--- | :--- |
| `POST` | `/generate` | 根据原始提示词生成新提示词 | `PromptEditor.vue` "生成" 按钮 |
| | | **Request Body (json):** `{ "originalPrompt": "..." }` | |
| | | **Response (json):** `{ "generatedPrompt": "..." }` | |
| `POST`| `/` | 保存一个提示词版本 | `PromptEditor.vue` "保存" 按钮 |
| `GET` | `/history` | 获取提示词历史记录 | `PromptEditor.vue` "历史记录" 按钮 |