
# 知识智能平台软件架构设计书 (v1.0)

**文档状态**: 草案
**最后更新**: 2025年10月15日

## 1\. 架构愿景与设计哲学

本架构旨在为“知识智能平台”提供一个高性能、高内聚、低耦合、易扩展的后端服务基础。设计的核心哲学是**关注点分离 (Separation of Concerns)**，确保每一层代码只做一件事，并通过明确定义的接口进行通信。

此架构不仅要满足当前企划书中的所有功能需求（如混合RAG、知识库管理等），更要为未来的功能扩展（如引入更多知识源、支持更复杂的分析任务）预留空间，避免随着业务复杂度的增加而导致代码的熵增。

## 2\. 架构总览：分层式架构 (Layered Architecture)

本系统采用经典的分层式架构，将应用垂直切分为多个职责明确的逻辑层。数据和请求在这些层之间单向流动，确保了清晰的依赖关系和数据流。

#### 模块总览图

```
app/
├── api/                  # 接口层 (Interface Layer)
│   ├── endpoints/
│   └── router.py
├── core/                 # 核心配置层 (Core Configuration Layer)
│   ├── config.py
│   └── lifespan.py
├── services/             # 业务逻辑层 (Business Logic/Service Layer)
│   ├── ingestion_pipeline.py
│   └── rag_service.py
├── crud/                 # 数据访问层 (Data Access Layer - CRUD)
│   └── crud_projects.py
├── models/               # 数据模型层 (Data Model Layer)
│   └── project.py
├── schemas/              # 数据模式层 (Data Schema Layer)
│   └── project.py
├── db/                   # 数据库会话层 (Database Session Layer)
│   └── session.py
└── main.py               # 应用入口 (Application Entrypoint)
```

## 3\. 模块职能细节

#### 3.1 `main.py`: 应用入口 (Application Entrypoint)

  * **职能**: 作为整个 FastAPI 应用的唯一启动点。
  * **细节**:
      * 它的代码应极其精简，只负责**三件事**：
        1.  导入 `core` 层的 `lifespan` 事件处理器。
        2.  创建 FastAPI 的主应用实例 `app`，并注册 `lifespan`。
        3.  包含 `api` 层的总路由器 `api.router`。
      * **禁止**: 任何数据库连接、业务逻辑、API路由定义都不应直接出现在此文件中。

#### 3.2 `core/`: 核心配置层 (Core Configuration Layer)

  * **职能**: 定义应用的全局配置、启动/关闭逻辑以及其他核心工具。
  * **细节**:
      * `config.py`: 使用 Pydantic 的 `Settings` 对象来安全地从环境变量（`.env` 文件）中加载所有配置，如数据库连接字符串、LLM API 密钥、Qdrant 地址等。这实现了配置与代码的完全分离。
      * `lifespan.py`: 包含 FastAPI 的 `lifespan` 事件处理器。它负责在应用启动时初始化数据库连接池、连接到 Qdrant 等资源密集型操作，并在应用关闭时优雅地释放这些资源。

#### 3.3 `api/`: 接口层 (Interface Layer)

  * **职能**: 定义所有对外暴露的 HTTP API 端点，是应用与外界（低代码前端）通信的唯一窗口。
  * **细节**:
      * **`endpoints/`**: 包含按功能划分的路由模块。例如，`projects.py` 定义 `/projects/upload`、`/projects/{project_id}` 等所有与项目管理相关的路由。`rag.py` 则定义 `/rag/query` 等查询接口。
      * **依赖注入**: 每个路由函数都会通过 FastAPI 的依赖注入系统，从 `services` 层获取服务实例，并调用其方法来完成业务逻辑。
      * **数据交互**: 路由函数接收 `schemas` 中定义的 Pydantic 模型作为请求体，并返回同样在 `schemas` 中定义的模型作为响应体。它本身不处理复杂的业务逻辑，只做请求的接收、校验和转发。
      * **`router.py`**: 一个聚合器，将 `endpoints/` 下的所有子路由汇集成一个 `APIRouter`，供 `main.py` 统一挂载。

#### 3.4 `services/`: 业务逻辑层 (Business Logic/Service Layer)

  * **职能**: **应用的核心大脑**。所有复杂的业务流程、算法和逻辑编排都在这一层实现。
  * **细节**:
      * **`ingestion_pipeline.py`**: 实现企划书中的“知识摄取管道”。它将包含接收文件 -\> 解压 -\> 遍历文件 -\> 智能切分 -\> 向量化 -\> 存入 Qdrant -\> 在关系型数据库中记录元数据等一系列复杂操作。
      * **`rag_service.py`**: 实现企划书中的两个 RAG 循环。它会接收用户查询，动态地根据元数据选择要检索的知识库（Agentic RAG），与 Qdrant 和 LLM 交互，并最终构建出增强提示词或生成结构化知识。
      * **依赖关系**: 服务层是唯一可以同时与`crud`层（操作元数据）和外部服务（如 Qdrant, LLM API）交互的层级。

#### 3.5 `db/`, `models/`, `crud/`: 数据持久化三层 (Data Persistence Layers)

  * **职能**: 完整地封装了与关系型数据库（如 PostgreSQL）的所有交互。
  * **细节**:
      * `db/session.py`: 负责创建 SQLAlchemy 的 `engine` 和 `SessionLocal`，是数据库连接的工厂。
      * `models/project.py`: 定义数据表的结构。使用 SQLAlchemy 的声明式类来映射 Python 对象到数据库表，例如 `Project` 模型将对应 `projects` 表。
      * `crud/crud_projects.py`: 提供了对 `Project` 模型原子化的增删改查操作（Create, Read, Update, Delete）。**这是整个应用中唯一允许编写并执行 SQL/ORM 查询的地方**。`services` 层通过调用这些 CRUD 函数来操作数据库，而不需要知道底层的 SQL 实现。

#### 3.6 `schemas/`: 数据模式层 (Data Schema Layer)

  * **职能**: 定义应用内部及 API 对外的数据结构和校验规则，是应用的“数据合同”。
  * **细节**:
      * 使用 **Pydantic** 模型来定义数据。例如，`ProjectCreate` schema 定义了创建一个项目需要哪些字段，`Project` schema 定义了从 API 返回一个项目时会包含哪些字段。
      * **用途**:
        1.  FastAPI 使用它来自动校验传入的 JSON 请求体。
        2.  FastAPI 使用它来序列化传出的数据，并过滤掉不应暴露的字段（如密码）。
        3.  自动生成 OpenAPI (Swagger UI) 文档。

## 4\. 架构设计借鉴与创新

#### 4.1 借鉴的经典设计模式

  * **分层架构 (Layered Architecture)**: 这是本架构的基石。通过将应用清晰地划分为表现层(`api`)、业务逻辑层(`services`)和数据访问层(`crud`, `models`)，实现了高度的模块化和解耦。
  * **依赖倒置原则 (Dependency Inversion Principle)**: 高层模块（如 `api`）不直接依赖于低层模块（如 `crud`），而是都依赖于抽象（通过 `services` 层进行中介）。例如，API 路由通过依赖注入使用服务，而不知道服务内部是如何与数据库交互的。
  * **仓库模式 (Repository Pattern)**: `crud` 层的设计思想借鉴了仓库模式。它将数据存储的细节（无论是 SQL 还是未来可能的 NoSQL）封装起来，为上层（`services`）提供一个干净、面向对象的接口来访问数据。
  * **单入口 (Single Entrypoint)**: `main.py` 的设计遵循了单入口原则，使得应用的启动和配置流程非常清晰。

#### 4.2 适应性创新

  * **专为 AI/RAG 服务设计的 `services` 层**: 传统的业务逻辑层通常处理的是用户、订单等业务，而本架构中的 `services` 层是专门为处理现代 AI 应用的复杂工作流而设计的。`ingestion_pipeline.py` 和 `rag_service.py` 就是这种创新体现，它们封装了与向量数据库、LLM、文档处理库等多种异构服务交互的复杂逻辑。
  * **元数据驱动的 Agentic RAG**: 本架构将关系型数据库（`models/`) 作为 Agentic RAG 的“指挥中心”。`rag_service.py` 在执行查询前，会先查询 `crud` 层获取知识库的元数据（哪些子知识库被激活），然后动态地构建检索策略。这是对企划书中“选择性检索”需求在架构层面的直接映射，是一个关键的创新点。
  * **Pydantic 的深度整合**: 除了作为 API 的数据合同 (`schemas/`)，Pydantic 也被用于 `core/config.py` 中进行配置管理。这种对 Pydantic 的深度利用，使得从外部配置到内部数据模型的类型安全和校验贯穿了整个应用。

## 5\. 架构的优缺点分析

#### 5.1 优点

1.  **高可维护性**: 严格的关注点分离使得代码定位和修改变得非常容易。当需求变更时，开发者可以快速找到需要修改的模块，而不用担心会影响到其他部分。
2.  **高可测试性**: 每一层都可以被独立测试。我们可以为 `crud` 层编写单元测试来验证数据库操作，为 `services` 层编写集成测试来验证业务逻辑，而无需启动完整的 Web 服务。
3.  **高可扩展性**:
      * **垂直扩展**: 添加新的 API 功能只需在 `endpoints`, `services`, `schemas` 等目录中添加新文件，而无需改动现有代码。
      * **水平替换**: 如果未来决定将 Qdrant 换成 Milvus，我们只需要修改 `services` 层中与向量数据库交互的部分，而 `api` 层和 `crud` 层完全不受影响。
4.  **团队协作友好**: 不同的开发者可以并行地在不同的层级上工作。例如，一位开发者可以专注于 `services` 层的 RAG 逻辑优化，而另一位则可以同时开发 `api` 层的新接口。

#### 5.2 缺点

1.  **前期开发成本较高**: 对于非常简单的应用，这种分层架构可能会显得“过度设计”，需要创建更多的文件和目录，增加了初期的开发工作量。
2.  **代码冗余的可能性**: 在某些简单的 CRUD 操作中，请求需要穿过 `api` -\> `services` -\> `crud` 三层，可能会产生一些模板化的代码。
3.  **对开发者的要求更高**: 开发者需要理解并遵守分层架构的规则，避免在错误的层级编写代码（例如，在 `api` 层直接进行数据库查询）。

**结论**: 尽管存在一些初期投入成本，但对于一个目标是长期演进、功能复杂的“知识智能平台”而言，本架构所带来的可维护性、可扩展性和健壮性优势，远远超过了其缺点。它为项目的健康发展奠定了坚实的基础。